import time
import requests
import base64
from urllib.parse import urlencode

class SpotifyService:
    BASE_URL = "https://api.spotify.com/v1"
    AUTH_URL = "https://accounts.spotify.com/api/token"

    def __init__(self, client_id, client_secret):
        self.client_id = client_id
        self.client_secret = client_secret

    def get_auth_headers(self, access_token):
        return {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

    def exchange_code_for_token(self, code, redirect_uri):
        auth_header = base64.b64encode(f"{self.client_id}:{self.client_secret}".encode()).decode("ascii")
        headers = {
            "Authorization": f"Basic {auth_header}",
            "Content-Type": "application/x-www-form-urlencoded"
        }
        data = {
            'code': code,
            'redirect_uri': redirect_uri,
            'grant_type': "authorization_code"
        }
        
        response = requests.post(self.AUTH_URL, data=data, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Token exchange failed: {response.text}")
        
        return response.json()

    def refresh_token(self, refresh_token):
        auth_header = base64.b64encode(f"{self.client_id}:{self.client_secret}".encode()).decode("ascii")
        headers = {
            "Authorization": f"Basic {auth_header}",
            "Content-Type": "application/x-www-form-urlencoded"
        }
        data = {
            'grant_type': 'refresh_token',
            'refresh_token': refresh_token
        }
        
        response = requests.post(self.AUTH_URL, data=data, headers=headers)
        if response.status_code != 200:
            raise Exception(f"Token refresh failed: {response.text}")
            
        return response.json()

    def search_track(self, access_token, song_name, artist_name):
        """
        Search for a track by name and artist. 
        Returns the first match or None.
        """
        # Sanitize inputs
        if not song_name or not artist_name:
            return None
            
        query = f"track:{song_name} artist:{artist_name}"
        params = {
            "q": query,
            "type": "track",
            "market": "US",
            "limit": 1
        }
        
        try:
            # 1. Try strict search first
            response = requests.get(
                f"{self.BASE_URL}/search", 
                headers=self.get_auth_headers(access_token),
                params=params,
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                items = data.get("tracks", {}).get("items", [])
                if items:
                    return items[0]
            elif response.status_code == 429:
                print("Rate limited by Spotify")
                return None

            # 2. Fallback: Relaxed search (just string matching)
            # Sometimes AI gives "Title - Remastered" or slightly off artist names
            relaxed_query = f"{song_name} {artist_name}"
            params["q"] = relaxed_query
            
            response = requests.get(
                f"{self.BASE_URL}/search", 
                headers=self.get_auth_headers(access_token),
                params=params,
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                items = data.get("tracks", {}).get("items", [])
                if items:
                    print(f"Fallback search successful for: {song_name}")
                    return items[0]
            
            return None
        except Exception as e:
            print(f"Error searching for {song_name} by {artist_name}: {e}")
            return None

    def create_playlist(self, access_token, user_id, name, description="Generated by Jam Genie", public=True):
        url = f"{self.BASE_URL}/users/{user_id}/playlists"
        data = {
            "name": name,
            "description": description,
            "public": public
        }
        
        response = requests.post(
            url, 
            headers=self.get_auth_headers(access_token),
            json=data
        )
        response.raise_for_status()
        return response.json()

    def add_tracks_to_playlist(self, access_token, playlist_id, uris):
        if not uris:
            return
            
        # Spotify API limit is 100 tracks per request
        # split into chunks if needed (though our AI limits are usually lower)
        url = f"{self.BASE_URL}/playlists/{playlist_id}/tracks"
        
        data = {"uris": uris}
        response = requests.post(
            url,
            headers=self.get_auth_headers(access_token),
            json=data
        )
        response.raise_for_status()
        return response.json()

    def get_user_profile(self, access_token):
        response = requests.get(
            f"{self.BASE_URL}/me",
            headers=self.get_auth_headers(access_token)
        )
        if response.status_code != 200:
            raise Exception(f"Failed to fetch profile: {response.text}")
        return response.json()

    def upload_playlist_cover(self, access_token, playlist_id, image_b64):
        """
        Uploads a custom cover image to a playlist.
        image_b64: Base64 encoded JPEG image data (max 256KB)
        """
        url = f"{self.BASE_URL}/playlists/{playlist_id}/images"
        
        # NOTE: the API wants the raw Base64 string in the body
        # Strip header if present (e.g. data:image/jpeg;base64,...)
        if "," in image_b64:
            image_b64 = image_b64.split(",")[1]
            
        # Per user request:
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "image/jpeg",
            "Accept": "application/json"
        }
        
        response = requests.put(
            url,
            headers=headers,
            data=image_b64
        )
        
        if response.status_code == 202:
             print(" Cover image uploaded!")
             return True
        else:
             print(f" Upload failed: {response.status_code} - {response.text}")
             return False
