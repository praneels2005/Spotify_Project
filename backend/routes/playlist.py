from flask import Blueprint, request, session, jsonify
import concurrent.futures
from ..config import Config
from ..services.spotify import SpotifyService
from ..services.ai import AIService

playlist_bp = Blueprint('playlist', __name__)

@playlist_bp.route('/Playlist_Generator', methods=['POST'])
@playlist_bp.route('/Generate_Preview', methods=['POST'])
def generate_preview():
    # 1. Auth Check
    if 'access_token' not in session:
        return jsonify({"error": "Not authenticated", "redirect": "/login"}), 401
    
    # 2. Get Params
    data = request.get_json() or {}
    preferences = data.get('preferences')
    if not preferences:
        return jsonify({"error": "No preferences provided"}), 400
        
    playlist_length = preferences.get("playlistLength", 20)
    # Handle if frontend sends a list (legacy support)
    if isinstance(playlist_length, list):
        playlist_length = playlist_length[0]
        
    try:
        playlist_length = int(playlist_length)
    except:
        playlist_length = 20

    # 3. AI Generation
    # Request extra songs to buffer against those not found on Spotify
    # Increase buffer to 100% of requested length or at least 10 songs to be safe
    buffer_count = max(10, int(playlist_length * 1.0)) 
    target_ai_count = playlist_length + buffer_count
    
    ai_service = AIService()
    spotify_service = SpotifyService(Config.SPOTIFY_CLIENT_ID, Config.SPOTIFY_CLIENT_SECRET)
    
    try:
        # Generate raw song list with buffer
        ai_songs = ai_service.generate_playlist_params(preferences, count=target_ai_count)
    except Exception as e:
        return jsonify({"error": "AI Generation failed", "details": str(e)}), 500

    # 4. Spotify Search (Parallelized)
    found_tracks = []
    
    # Extract token from session in the main thread
    access_token = session['access_token']
    
    def search_worker(token, song_info):
        return spotify_service.search_track(
            token, 
            song_info.get('name'), 
            song_info.get('artist')
        )

    # Use ThreadPool to search faster
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        # Pass access_token explicitely to avoid context issues
        future_to_song = {executor.submit(search_worker, access_token, song): song for song in ai_songs}
        
        for future in concurrent.futures.as_completed(future_to_song):
            try:
                track = future.result()
                if track:
                    found_tracks.append(track)
            except Exception as e:
                print(f"Search error: {e}")

    if not found_tracks:
        return jsonify({"error": "No songs found on Spotify matching the criteria"}), 404
        
    # Trim to requested length if we found extra
    found_tracks = found_tracks[:playlist_length]

    # Return preview data (no playlist created yet)
    track_previews = []
    for t in found_tracks:
        # Check if we have image
        image = "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=100&h=100&fit=crop" # Default
        if t.get('album', {}).get('images'):
            image = t['album']['images'][0]['url']
            
        track_previews.append({
            "id": t['id'],
            "uri": t['uri'],
            "title": t['name'],
            "artist": t['artists'][0]['name'],
            "album": t['album']['name'],
            "duration": f"{int(t['duration_ms']/60000)}:{int((t['duration_ms']%60000)/1000):02d}",
            "image": image,
            "preview_url": t.get('preview_url')
        })

    return jsonify({
        "tracks": track_previews,
        "count": len(found_tracks),
        "totalDuration": "Calculating..." # Frontend can calc precise duration
    })

@playlist_bp.route('/Create_Playlist', methods=['POST'])
def create_playlist():
    if 'access_token' not in session:
        return jsonify({"error": "Not authenticated", "redirect": "/login"}), 401

    data = request.get_json() or {}
    name = data.get('name', 'AI Generated Bundle')
    description = data.get('description', 'Generated by PlaylistAI')
    uris = data.get('uris', [])
    image = data.get('image') # Base64 string

    if not uris:
         return jsonify({"error": "No tracks provided"}), 400

    spotify_service = SpotifyService(Config.SPOTIFY_CLIENT_ID, Config.SPOTIFY_CLIENT_SECRET)

    try:
        user_id = session.get('spotify_user_id')
        if not user_id:
            # Try to fetch if missing
            profile = spotify_service.get_user_profile(session['access_token'])
            user_id = profile['id']
            session['spotify_user_id'] = user_id

        playlist = spotify_service.create_playlist(
            session['access_token'],
            user_id,
            name=name,
            description=description,
            public=True
        )
        
        # Add Tracks
        spotify_service.add_tracks_to_playlist(
            session['access_token'],
            playlist['id'],
            uris
        )

        # Upload Image if provided
        if image:
            try:
                # Add slight delay to ensure playlist is ready? 
                # Spotify API usually handles it fine, but sometimes it takes a moment.
                spotify_service.upload_playlist_cover(
                    session['access_token'],
                    playlist['id'],
                    image
                )
            except Exception as img_err:
                print(f"Failed to upload image: {img_err}")
                # Don't fail the whole request, just log it
        
        return jsonify({
            "playlist_id": playlist['id'],
            "message": "Playlist created successfully"
        })

    except Exception as e:
        print(f"Playlist creation failed: {e}")
        return jsonify({"error": "Failed to create playlist on Spotify", "details": str(e)}), 500

@playlist_bp.route('/Search_Track', methods=['GET'])
def search_spotify_track():
    if 'access_token' not in session:
        return jsonify({"error": "Not authenticated"}), 401

    query = request.args.get('q')
    if not query:
        return jsonify({"error": "Missing query"}), 400

    spotify_service = SpotifyService(Config.SPOTIFY_CLIENT_ID, Config.SPOTIFY_CLIENT_SECRET)
    
    # We'll use a direct search here, reusing search_track logic or calling raw search
    # Since search_track in service is specific to track/artist, let's just do a raw search here or add a general search to service.
    # For now, let's use the service's existing base URL but we need a general search.
    # Actually, let's just use requests here for simplicity or extend service.
    # Extending service is cleaner.
    
    try:
        # Reuse search_track logic but treat query as song name and ignore artist if not provided?
        # Or better, just call Spotify Search API directly here for flexible search
        params = {
            "q": query,
            "type": "track",
            "market": "US",
            "limit": 10
        }
        
        response = requests.get(
            f"{SpotifyService.BASE_URL}/search", 
            headers=spotify_service.get_auth_headers(session['access_token']),
            params=params
        )
        
        if response.status_code != 200:
             return jsonify({"error": "Spotify search failed"}), response.status_code
             
        data = response.json()
        tracks = data.get('tracks', {}).get('items', [])
        
        # Format for frontend
        results = []
        for t in tracks:
            image = "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=100&h=100&fit=crop"
            if t.get('album', {}).get('images'):
                image = t['album']['images'][0]['url']
                
            results.append({
                "id": t['id'],
                "uri": t['uri'],
                "title": t['name'],
                "artist": t['artists'][0]['name'],
                "album": t['album']['name'],
                "duration": f"{int(t['duration_ms']/60000)}:{int((t['duration_ms']%60000)/1000):02d}",
                "image": image
            })
            
        return jsonify(results)

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@playlist_bp.route('/Get_Playlists', methods=['GET'])
def get_playlists():
    if 'access_token' not in session:
        return jsonify({"error": "Not authenticated"}), 401
        
    spotify_service = SpotifyService(Config.SPOTIFY_CLIENT_ID, Config.SPOTIFY_CLIENT_SECRET)
    try:
        # Simplified for now, just getting user's playlists
        # Logic from main2.py could be adapted if specific playlist fetching is needed
        # But this route seemed generic in main2.py
        
        params = {"limit": 50}
        response = requests.get(
            f"{SpotifyService.BASE_URL}/me/playlists",
            headers=spotify_service.get_auth_headers(session['access_token']),
            params=params
        )
        return jsonify(response.json())
    except Exception as e:
        return jsonify({"error": str(e)}), 500
